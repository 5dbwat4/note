# Binary Tree

## 定义 of Tree
- **节点的度数**（degree of a node）::= 节点的子树数量。  
- **树的度数**（degree of a tree）::= 树中所有节点的最大度数。例如，图中树的度数为3。  
- **父节点**（parent）::= 拥有子树的节点。  
- **子节点**（children）::= 父节点的子树根节点。  
- **兄弟节点**（siblings）::= 同一父节点的所有子节点。  
- **叶子节点**（leaf/terminal node）::= 度数为0的节点（无子节点）。

- **从$n_1$到$n_k$的路径**（path）::= 唯一节点序列 $n_1,n_2,\cdots,n_k$，其中 $n_i$ 是 $n_{i+1}$ 的父节点（$1 \le i < k$）。  
- **路径长度**（length of path）::= 路径上的边数。  
- **节点$n_i$的深度**（depth）::= 从根节点到$n_i$的唯一路径长度。根节点的深度为0。  
- **节点$n_i$的高度**（height）::= 从$n_i$到最深叶子节点的最长路径长度。叶子节点的高度为0，例如节点D的高度为2。  
- **树的高度/深度** ::= 根节点的高度（或最深叶子节点的深度）。  
- **祖先**（ancestors）::= 从节点到根节点路径上的所有节点。  
- **后裔**（descendants）::= 节点所有子树中的节点。


## Definition of binary tree

【Definition】A **binary tree** is a tree in which no node can have more than two children.

## Traversal

省流：

- 先序遍历（Preorder Traversal）：根节点 → 左子树 → 右子树
- 中序遍历（Inorder Traversal）：左子树 → 根节点 → 右子树
- 后序遍历（Postorder Traversal）：左子树 → 右子树 → 根节点

### 先序遍历（Preorder Traversal）
**访问顺序**：根节点 → 左子树 → 右子树

**实现**
```c
void  preorder ( tree_ptr  tree )
{  if  ( tree )   {
        visit ( tree );
        for (each child C of tree )
            preorder ( C );
    }
}
```

**常见用途**

- 目录树结构复制（保留树形关系）
- 数学表达式前缀表示（波兰表达式）
- 场景调试时优先观察父节点逻辑

### 中序遍历（Inorder Traversal）
**访问顺序**：左子树 → 根节点 → 右子树

**实现**
```c
void  inorder ( tree_ptr  tree )
{  if  ( tree )   {
        inorder ( tree->Left );
        visit ( tree->Element );
        inorder ( tree->Right );
   }
}
```

Iterative Program
```c
void  iter_inorder ( tree_ptr  tree )
{ Stack  S = CreateStack( MAX_SIZE );
  for ( ; ; )  {
     for ( ; tree; tree = tree->Left )
        Push ( tree, S ) ;
     tree = Top ( S );  Pop( S );
     if ( ! tree )  break;
     visit ( tree->Element );
     tree = tree->Right;   }
}
```

**常见用途**

- 二叉搜索树（BST）产生有序序列
- 数学表达式的中缀表示（需补全括号）
- 扁平化打印排序数据场景

### 后序遍历（Postorder Traversal）
**访问顺序**：左子树 → 右子树 → 根节点

**实现**
```c
void  postorder ( tree_ptr  tree )
{  if  ( tree )   {
        for (each child C of tree )
            postorder ( C );
        visit ( tree );
    }
}
```

**常见用途**

- 计算目录树总大小（先统计子目录）
- 内存释放操作（需先释放子节点）
- 数学表达式后缀表示（逆波兰表达式）

### 层序遍历（Levelorder Traversal）
**访问顺序**：按层级从左到右逐层访问

**实现**
```c
void  levelorder ( tree_ptr  tree )
{   enqueue ( tree );
    while (queue is not empty) {
        visit ( T = dequeue ( ) );
        for (each child C of T )
            enqueue ( C );
    }
}
```

**常见用途**

- 寻找最短路径（BFS算法基础）
- 按层级生成编码结构（如DNA序列树）
- 社交网络层级关系可视化

## 前中后序遍历建树

- **唯一建树的组合**：前序+中序、中序+后序。  
- **无法唯一建树**：前序+后序（除非树满足特定条件，如满二叉树）。  

### **1. 前序+中序：唯一确定树**
- **原理**：  
  前序遍历的第一个节点是根，中序遍历的根将序列分为左、右子树。通过递归分割，可唯一确定树的结构。
  
- **实现步骤**：  
  1. **定位根**：前序的首元素为根。  
  2. **分割中序**：在中序中找到根的位置，左侧为左子树的中序，右侧为右子树的中序。  
  3. **分割前序**：根据左子树的节点数，将前序中根后的部分分为左子树的前序和右子树的前序。  
  4. **递归构建**：对左、右子树重复上述过程，直至叶子节点。

### **2. 中序+后序：唯一确定树**
- **原理**：  
  后序遍历的最后一个节点是根，中序遍历的根分割左右子树。递归分割可唯一确定树。

- **实现步骤**：  
  1. **定位根**：后序的末元素为根。  
  2. **分割中序**：在中序中找到根的位置，分割左、右子树的中序。  
  3. **分割后序**：根据左子树的节点数，将后序中除根外的部分分为左子树的后序和右子树的后序。  
  4. **递归构建**：对左、右子树重复上述过程。


## 给定一个序列，判断是不是前中后序遍历

省流版：
- Postorder traversal：`[小于N序列][大于N序列]N`，不能有交错
- Preorder traversal：`N[小于N序列][大于N序列]`，不能有交错
- Inorder traversal：严格递增

Deepseek版：

要判断一个给定的序列是否是二叉搜索树（BST）的中序、前序或后序遍历，可以依据这三种遍历方式的特点来进行分析，以下是具体判断方法：

### 判断是否为中序遍历序列
中序遍历二叉搜索树的顺序是：先遍历左子树，然后访问根节点，最后遍历右子树。对于二叉搜索树而言，中序遍历的结果具有一个重要特性：序列中的元素是按升序排列的。

因此，判断一个序列是否为二叉搜索树的中序遍历序列，只需检查该序列是否是严格递增的（假设树中没有重复元素）。具体步骤如下：
1. 从序列的第二个元素开始，依次与它的前一个元素进行比较。
2. 如果当前元素小于或等于前一个元素，那么该序列不是二叉搜索树的中序遍历序列。
3. 如果遍历完整个序列都没有发现违反升序规则的情况，那么该序列就是二叉搜索树的中序遍历序列。

### 判断是否为前序遍历序列
前序遍历二叉搜索树的顺序是：先访问根节点，然后遍历左子树，最后遍历右子树。对于二叉搜索树的前序遍历序列，第一个元素一定是整棵树的根节点，从根节点之后的元素开始，会存在一个分割点，使得分割点之前的元素（除根节点外）都小于根节点（这些元素构成左子树），分割点之后的元素都大于根节点（这些元素构成右子树）。

判断步骤如下：
1. 确定序列的第一个元素为根节点。
2. 从第二个元素开始遍历序列，找到第一个大于根节点的元素，这个元素就是右子树的起始位置。
3. 检查右子树部分的元素是否都大于根节点，如果有小于根节点的元素，则该序列不是二叉搜索树的前序遍历序列。
4. 对于左子树部分（根节点之后到右子树起始位置之前的元素），递归地将其当作一个新的前序遍历序列，重复上述步骤进行判断。

### 判断是否为后序遍历序列
后序遍历二叉搜索树的顺序是：先遍历左子树，然后遍历右子树，最后访问根节点。对于二叉搜索树的后序遍历序列，最后一个元素一定是整棵树的根节点，从序列开头开始，会存在一个分割点，使得分割点之前的元素（除最后一个元素外）中，一部分小于根节点（这些元素构成左子树），另一部分大于根节点（这些元素构成右子树）。

判断步骤如下：
1. 确定序列的最后一个元素为根节点。
2. 从序列的第一个元素开始遍历，找到第一个大于根节点的元素，这个元素就是右子树的起始位置。
3. 检查左子树部分（序列开头到右子树起始位置之前的元素）是否都小于根节点，如果有大于根节点的元素，则该序列不是二叉搜索树的后序遍历序列。
4. 检查右子树部分（右子树起始位置到倒数第二个元素）是否都大于根节点，如果有小于根节点的元素，则该序列不是二叉搜索树的后序遍历序列。
5. 对于左子树部分和右子树部分，递归地将其当作新的后序遍历序列，重复上述步骤进行判断。

## 线索二叉树（Threaded Binary Tree）

本来的lead它的leaf不是null嘛，现在把这些leaf指向traversal中它的下一位，然后称其为thread（线索）。