# Halting Problem 停机问题

【Example】Halting problem:  Is it possible to have your C compiler detect all infinite loops?


# 可规约性

Reduction: 


设 $X, Y$ 是两个问题，记 $X \leq_P Y$ 表示“$X$ 可以多项式时间归约到 $Y$”。


**多项式时间归约的定义**：
若满足以下条件，则 $X$ 多项式时间归约到 $Y$：
1. 用**多项式次**的标准计算步骤；
2. 用**多项式次**对“能求解 $Y$ 的神谕（oracle）”的调用；
且 $Y$ 的输入规模 $|I_Y|$ 是多项式大小的。


**归约的性质（若 $X \leq_P Y$）**：
1. 若 $Y$ 能在多项式时间内求解，则 $X$ 也能在多项式时间内求解；
2. 若 $X$ 不能在多项式时间内求解，则 $Y$ 也不能在多项式时间内求解。


$X \leq_P Y$


$X$ polynomial-time reduces to $Y$ if we can solve $X$ using
(1) Polynomial number of standard computational steps
(2) Polynomial number of calls to an oracle that solves $Y$.
$|I_Y|$ is polynomial-size.


Suppose $X \leq_P Y$.

(1) If $Y$ can be solved in polynomial-time,
then $X$ can solved in polynomial time.

(2) If $X$ cannot be solved in polynomial time.
then neither can $Y$.

## 课上的例子

**例子1**：

Given a weighted graph $G$, two vertices $s$ and $t$.
- (1) find the shortest path from $s$ to $t$
- (2) given $k$, find a $s \rightsquigarrow t$ path with length $\leq k$
- (3) given $k$, $\exists$ a $s \rightsquigarrow t$ path with length $\leq k$

有：$(3) \leq_P (2) \leq_P (1)$且$(1) \leq_P (2) \leq_P (3)$

$(3) \leq_P (2) \leq_P (1)$是显然的，下面说明$(1) \leq_P (2)$和$(2) \leq_P (3)$：


- (1) $\leq_p$ (2)：问题 (1) 可以归约到问题 (2)。如果我们有一个算法能解决问题 (2)，那么我们可以通过二分搜索来找到最短路径长度。具体来说，我们可以通过调用问题 (2) 多次（使用不同的 $k$ 值）来找到最小的 $k$ 使得存在路径长度不超过 $k$，此时该路径就是最短路径。这一过程在多项式时间内完成（假设路径长度范围已知或可估计）。
- (2) $\leq_p$ (3)：

    假设我们有一个算法 $A(G, s, t, k)$ 用于问题 (3)，它返回 `True` 如果存在一条从 $s$ 到 $t$ 的路径长度不超过 $k$，否则返回 `False`。我们想要解决问题 (2)，即找到一条这样的路径。以下是归约的具体算法：

    1. **初始检查**：首先调用 $A(G, s, t, k)$。如果返回 `False`，则直接输出“无解”（因为不存在这样的路径）。如果返回 `True`，则继续下一步。

    2. **路径构建**：从顶点 $s$ 开始，逐步构建路径 $P$。初始化 $P = [s]$，当前顶点 $u = s$。

    3. **迭代选择下一个顶点**：当当前顶点 $u$ 不是 $t$ 时，执行以下循环：
       - 对于 $u$ 的每个邻居顶点 $v$（按任意顺序遍历，例如顶点编号顺序），考虑边 $(u, v)$ 权重为 $w(u,v)$。
       - 创建一个新图 $G'$，它是原图 $G$ 的修改版本：移除从 $u$ 出发的所有其他边，只保留边 $(u, v)$。这确保了任何从 $s$ 到 $t$ 的路径在 $G'$ 中必须使用边 $(u, v)$。
       - 调用 $A(G', s, t, k)$：
         - 如果返回 `True`，说明存在一条从 $s$ 到 $t$ 的路径使用边 $(u, v)$ 且长度不超过 $k$。因此，将 $v$ 加入路径 $P$，更新 $u = v$，并跳出当前循环（即不再检查 $u$ 的其他邻居）。
         - 如果返回 `False`，则继续检查 $u$ 的下一个邻居。
       - 如果所有邻居都检查完毕但未找到符合条件的 $v$，则理论上这不应发生，因为初始检查已确认路径存在；但万一发生，则报错（可能由于算法实现问题）。

    4. **终止**：当 $u = t$ 时，路径 $P$ 即为所求，输出 $P$。

**例子2: Independent Set 和 Vertex Cover**

1. 独立集（Independent Set）
- *问题描述*：给定一个图 $G = (U, E)$，其中 $U$ 是顶点集合，$E$ 是边集合，以及一个整数 $k$。独立集问题要求判断是否存在一个顶点子集 $S \subseteq U$，使得：
  - $S$ 包含至少 $k$ 个顶点（即 $|S| \geq k$）。
  - $S$ 中任意两个顶点之间都没有边连接（即没有两个顶点相邻）。
- *通俗解释*：独立集是一个顶点集合，其中没有两个顶点是直接通过边相连的。问题是要检查图中是否存在这样一个“互不相邻”的顶点集合，且集合大小至少为 $k$。

2. 顶点覆盖（Vertex Cover）
- *问题描述*：给定一个图 $G = (U, E)$ 和一个整数 $k$。顶点覆盖问题要求判断是否存在一个顶点子集 $C \subseteq U$，使得：
  - $C$ 包含至多 $k$ 个顶点（即 $|C| \leq k$）。
  - 图中的每条边都至少有一个端点属于 $C$。
- *通俗解释*：顶点覆盖是一个顶点集合，它“覆盖”了图中的所有边，即每条边至少有一个端点在这个集合中。问题是要检查是否存在这样一个集合，且集合大小至多为 $k$。

互推：



1.  **（⇒）如果 $S$ 是一个大小至少为 $k$ 的独立集，那么 $V\setminus S$ 是一个大小至多为 $|V|-k$ 的顶点覆盖。**
    *   **证明 $V\setminus S$ 是一个顶点覆盖：** 我们需要证明每条边至少有一个端点在 $V\setminus S$ 中。
        *   假设有一条边 $e=(u,v)$，它的两个端点 $u$ 和 $v$ 都不在 $V\setminus S$ 中。那么 $u$ 和 $v$ 都必须在 $S$ 中。
        *   但是，如果 $u$ 和 $v$ 都在 $S$ 中，而 $S$ 是一个独立集，这意味着 $S$ 中不能有相邻的顶点，这与 $e=(u,v)$ 是一条边相矛盾。
        *   因此，我们的假设错误。每条边至少有一个端点不在 $S$ 中，也就是说，至少有一个端点在 $V\setminus S$ 中。所以 $V\setminus S$ 是一个顶点覆盖。
    *   **大小：** 因为 $|S| \ge k$，所以 $|V\setminus S| = |V| - |S| \le |V| - k$。

2.  **（⇐）如果 $C$ 是一个大小至多为 $l$ 的顶点覆盖，那么 $V\setminus C$ 是一个大小至少为 $|V|-l$ 的独立集。**
    *   **证明 $V\setminus C$ 是一个独立集：** 我们需要证明在 $V\setminus C$ 中，任意两个顶点之间都没有边相连。
        *   假设 $V\setminus C$ 中存在两个顶点 $u$ 和 $v$，它们之间有一条边 $e=(u,v)$。
        *   因为 $u$ 和 $v$ 都在 $V\setminus C$ 中，这意味着它们都不在顶点覆盖 $C$ 中。
        *   但是，边 $e$ 的两个端点都不在 $C$ 中，这与 $C$ 是一个顶点覆盖（要求覆盖所有边）相矛盾。
        *   因此，我们的假设错误。在 $V\setminus C$ 中，任意两个顶点之间都没有边。所以 $V\setminus C$ 是一个独立集。
    *   **大小：** 因为 $|C| \le l$，所以 $|V\setminus C| = |V| - |C| \ge |V| - l$。

**例子3: 哈密顿环问题 和 旅行商问题**

1. 哈密顿回路问题（Hamiltonian Cycle Problem）  
    给定一个无向图，问题是要判断是否存在一个回路（即一条闭合路径），使得该回路经过图中的每个顶点恰好一次。

2. 旅行商问题（Traveling Salesman Problem, TSP）  
    给定一组城市（即顶点）和每对城市之间的距离（即边上的权重），问题是要找到一条最短可能的路线，使得旅行商访问每个城市恰好一次并返回起点城市。


- **哈密顿回路问题规约到旅行商问题**：  
  给定一个哈密顿回路问题的实例（即一个无向图 $G = (V, E)$），我们可以构造一个TSP实例：  
  - 创建一个完全图 $G'$，其中顶点集与 $G$ 相同。  
  - 对于 $G'$ 中的每对顶点 $u$ 和 $v$，如果 $(u, v)$ 是 $G$ 中的边，则设置距离为 0；否则，设置距离为 1（或任意大于 1 的常数）。  
  然后，在 $G'$ 中求解TSP：如果存在一条总距离为 0 的路线，则原图 $G$ 存在哈密顿回路；否则，不存在。这是因为总距离为 0 的路线恰好对应 $G$ 中使用原边构成的哈密顿回路。这个规约显示了哈密顿回路问题可以在多项式时间内转化为TSP，因此TSP至少和哈密顿回路问题一样难（即NP难）。


# P/NP

- P 类问题：能在多项式时间内求解的问题。
- NP 类问题：能在多项式时间内验证解的问题。
- NP Hard 类问题：所有 NP 问题都能多项式时间归约到该问题的问题。
- NP Complete 类问题：既是 NP 问题又是 NP Hard 问题。

Overall：

除非 $P=NP$，否则不存在：

1. for all instances
2. find an optimal solution
3. in polynomial time