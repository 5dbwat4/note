---
title: Red-Black Tree
---

import {NImage} from "naive-ui";

Visualization: https://www.cs.usfca.edu/~galles/visualization/RedBlack.html

# What is a Red-Black Tree?

【Definition】A red-black tree is a binary search tree that satisfies the following red-black properties:

1.  Every node is either <span style="color:red;font-weight:bold">red</span> or <span style="color:black;font-weight:bold">black</span>.
2.  The root is <span style="color:black;font-weight:bold">black</span>.
3.  Every leaf (NIL) is <span style="color:black;font-weight:bold">black</span>.
4.  If a node is <span style="color:red;font-weight:bold">red</span>, then both its children are <span style="color:black;font-weight:bold">black</span>.
5.  For each node, all simple paths from the node to descendant leaves contain the same number of <span style="color:black;font-weight:bold">black</span> nodes.

【Definition】 The black-height of any node x, denoted by bh(x), is the number of black nodes on any simple path from x (x not included) down to a leaf.  bh(Tree) = bh(root).

\* myc课上的定义中，x is included

# Properties

1. For 2 children v & w of a node u, bh(v) = bh(w).
2. $\forall x \in \text{Tree}, h(x) \geq bh(x) \geq \frac{h(x)}{2}$.

通过上述机制，保证了$\frac{1}{2}  \leq \frac{h(v)}{h(w)} \leq 2$.

【Lemma】 A red-black tree with N internal nodes has height at most 2ln(N +1).

\* 课上说的是$2\log_2(N+1) +2$

Proof Idea: Show that a subtree with root x contains at least $2^{bh(x)} -1$ internal nodes.

By induction on the height of x:
- Base case: If h(x) = 0, then x is a leaf, so it contains $2^0 -1 = 0$ internal nodes.
- Inductive step: If h(x) > 0, then x has two children, say y and z. By the inductive hypothesis, each of the subtrees rooted at y and z contains at least $2^{bh(y)} -1$ and $2^{bh(z)} -1$ internal nodes, respectively. By property 1, bh(y) = bh(z) = bh(x) - 1 (?). Therefore, the subtree rooted at x contains at least:
  $$(2^{bh(x) - 1} - 1) + (2^{bh(x) - 1} - 1) + 1 = 2^{bh(x)} - 1$$
  internal nodes.

# Insertion
To insert a node z into a red-black tree, we:

1. perform a standard binary search tree insertion, coloring the new node z <span style="color:red;font-weight:bold">red</span>. 

2. This may violate the red-black properties, so we need to fix any violations.

We denote the parent of a node z as p(z), the grandparent as g(z), and the uncle as u(z).
We have the following cases to consider:
- **Case 1**: p(z) is <span style="color:black;font-weight:bold">black</span>. In this case, the tree is still a valid red-black tree, and we are done.
- **Case 2**: p(z) is <span style="color:red;font-weight:bold">red</span>. In this case, we have a violation of property 4. We need to consider the color of u(z):
  - **Case 2a**: u(z) is <span style="color:red;font-weight:bold">red</span>. In this case, we can recolor p(z) and u(z) to <span style="color:black;font-weight:bold">black</span> and g(z) to <span style="color:red;font-weight:bold">red</span>. Then, we set z = g(z) and repeat the process from step 2.
  - **Case 2b**: u(z) is <span style="color:black;font-weight:bold">black</span> (or NIL). In this case, we need to perform rotations to fix the violation. We have two sub-cases:
    - **Case 2b(i)**: z is a right child of p(z) and p(z) is a left child of g(z) (or vice versa). In this case, we perform a rotation on p(z) to make z a left child of g(z) (or vice versa). This transforms the situation into Case 2b(ii).
    - **Case 2b(ii)**: z is a left child of p(z) and p(z) is a left child of g(z) (or both are right children). In this case, we perform a rotation on g(z), making p(z) the new root of the subtree. We then recolor p(z) to <span style="color:black;font-weight:bold">black</span> and g(z) to <span style="color:red;font-weight:bold">red</span>(Case 2a).

import Img1 from "./assets/rbt-1.svg?url"

<NImage src={Img1} alt="rbt-1" />

# Deletion

参考： https://www.cs.purdue.edu/homes/ayg/CS251/slides/chap13c.pdf

1. 标准的BST删除：Leaf直接删除； 1 child的node，child上移； 2 children的node，找in-order successor替换，然后删除successor。

2. 所以目前，删除的节点一定是叶节点。如果它是红的，everything is fine.

3. 如果它是黑的，可能会破坏black-height Property。将这个节点定为Double Black，我们要做的是找到最近的Red node中和它。所以有几种情况：1. 在附近的兄弟那找到了这样的节点；2. 这个节点是root，因此直接移除Double Black状态；3. 未能找到，因此【将兄弟节点置为Red，父节点增加一个Black，自己变成单黑】，通过这种方式传递了Double Black状态。

4. 自然引出以下问题：什么是“找到”。事实上，我们暂时不在意这个“找”，而是关注*什么情况下，可以进入情况3*。  
   它的兄弟节点是黑的，兄弟节点的两个儿子也是黑的。

5. 到这里的过程都很容易理解。为什么要这么理解？我是因为对于初学者来说，RB Tree的Case很多，死记Case以及Case对应的Rotation变换比较难。

6. 那么，对于*非情况3*，要么转化成情况3，要么直接解决Double Black。现在可以分类了：  
    1. 兄弟节点是红的（那么两个儿子都是黑的）：旋转，将红的节点挪到双黑那条链上（变成它的父亲），于是直接中和
    2. 兄弟节点是黑的，两个儿子都是红的：儿子变黑，兄弟变红，进入情况1
    3. 兄弟节点是黑的，儿子一红一黑：核心