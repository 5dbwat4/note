---
title: Splay Tree
---

https://www.cs.usfca.edu/~galles/visualization/SplayTree.html

# Why Splay Tree?

Target :  Any M consecutive tree operations starting from an empty tree take at most $O(M log N)$ time.
Idea :  After a node is accessed, it is pushed to the root by a series of AVL tree rotations.

相比于AVL Tree：自适应性：频繁访问的节点会被快速移动到树的根部，从而加快后续访问速度。

{/* # Principles of the operations

- 搜索：使用普通二叉搜索树的方法找到结点，然后通过splay操作经过一系列旋转将搜索的结点移动到根结点的位置；
- 插入：使用普通二叉搜索树的方法找到要插入的位置进行插入，然后把刚刚插入的结点通过splay操作经过一系列旋转移动到根结点的位置；
- 删除：使用普通二叉搜索树的方法找到要删除的结点，然后通过splay操作经过一系列旋转将要删除的结点移动到根结点的位置，然后删除根结点（现在根结点就是要删除的点），然后和普通二叉搜索树的删除一样进行合理的merge即可。 */}

# Not use common rotations
非常naive的想法，就是不断地把访问的结点与其父结点更换父子关系，事实上就是不断用SingleRotation 翻到根结点的位置。然而这个例子告诉你，这么做之后虽然把要访问的结点放到了根结点，但其它有的结点被移动到了很深的位置

# splay


Splay 树要求每访问一个节点 $x$ 后都要强制将其旋转到根节点。该操作也称为伸展操作。

设刚访问的节点为 $x$。要做伸展操作，就是要对 $x$ 做一系列的 **伸展步骤**。每次对 $x$ 做一次伸展步骤，$x$ 到根节点的距离都会更近。定义 $p$ 为 $x$ 的父节点。伸展步骤有三种：

1.  **zig**: 在 $p$ 是根节点时操作。Splay 树会根据 $x$ 和 $p$ 间的边旋转。**zig** 存在是用于处理奇偶校验问题，仅当 $x$ 在伸展操作开始时具有奇数深度时作为伸展操作的最后一步执行。

    ![splay-zig](./assets/splay-zig.svg)

    即直接将 $x$ 右旋或左旋（图 1, 2）。

    ![图 1](./assets/splay-rotate1.svg)![图 2](./assets/splay-rotate2.svg)

2.  **zig-zig**: 在 $p$ 不是根节点且 $x$ 和 $p$ 都是右侧子节点或都是左侧子节点时操作。下方例图显示了 $x$ 和 $p$ 都是左侧子节点时的情况。Splay 树首先按照连接 $p$ 与其父节点 $g$ 边旋转，然后按照连接 $x$ 和 $p$ 的边旋转。

    ![splay-zig-zig](./assets/splay-zig-zig.svg)

    即首先将 $p$ 右旋或左旋，然后将 $x$ 右旋或左旋（图 3, 4）。

    ![图 3](./assets/splay-rotate3.svg)![图 4](./assets/splay-rotate4.svg)

3.  **zig-zag**: 在 $p$ 不是根节点且 $x$ 和 $p$ 一个是右侧子节点一个是左侧子节点时操作。Splay 树首先按 $p$ 和 $x$ 之间的边旋转，然后按 $x$ 和 $g$ 新生成的结果边旋转。

    ![splay-zig-zag](./assets/splay-zig-zag.svg)

    即将 $x$ 先左旋再右旋或先右旋再左旋（图 5, 6）。

    ![图 5](./assets/splay-rotate5.svg)![图 6](./assets/splay-rotate6.svg)


# Other Operations

## `find(x)`

1. Perform a standard BST search for the node with value `x`.
2. If the node is found, perform `splay(x)` to move it to the root.

## `insert(x)`
1. Perform a standard BST insertion for the node with value `x`.
2. Perform `splay(x)` to move the newly inserted node to the root.

## `delete(x)`
1. Perform `find(x)` to locate the node with value `x` (Now `x` is at the root).
2. If `x` has only one child, replace the root with that child.
3. If `x` has two children, find the maximum node in the left subtree (let's call it `y`), perform `splay(y)` to move it to the root of the left subtree, and then attach the right subtree of `x` as the right child of `y`.  
![alt text](assets/3-image-2.png)


# References

https://oi-wiki.org/ds/splay/