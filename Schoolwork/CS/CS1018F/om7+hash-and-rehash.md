# hash and rehash

### 1. **开放寻址法 (Open Addressing)**

**核心思想**：所有元素直接存储在哈希表数组中，冲突时通过**探测序列**寻找下一个空闲槽位。
**负载因子 (λ)**：必须满足 λ ≤ 1（元素数 ≤ 数组大小）。

#### (1) **线性探测 (Linear Probing)**

- **探测序列**：`h(key, i) = (hash(key) + i) % size`
- **操作**：
  - **插入**：若槽位被占，顺序检查下一个位置（`i=1,2,3...`）。
  - **查找**：从哈希位置开始顺序查找，直到遇到空槽或找到元素。
- **缺点**：易产生**聚集（Clustering）**，导致查找效率下降。
- **示例**：
  `hash(key)=3`，槽位 `[3,4,5]` 已占 → 插入到位置 `6`。

#### (2) **二次探测 (Quadratic Probing)** 注释：the second detection and hashing method也是指这个

- **探测序列**：`h(key, i) = (hash(key) + c1*i + c2*i²) % size`
- **特点**：以二次方跳跃式探测（如 `i=1,4,9...`），减少聚集。
- **限制**：可能无法找到空闲槽（即使存在），需满足表大小为质数且负载因子 λ<0.5。
- **示例**：
  `hash(key)=2`，冲突后尝试 `2+1²=3` → `2+2²=6` → `2+3²=11`...

---

### 2. **链地址法 (Chaining)**

**核心思想**：每个槽位指向一个**链表**，冲突元素直接添加到链表末尾。**负载因子 (λ)**：允许 λ > 1（元素数可超过数组大小）。

- **操作**：
  - **插入**：哈希到槽位后，将元素追加到链表尾部。
  - **查找**：遍历对应槽位的链表。
- **优点**：简单、避免聚集，允许动态增长。
- **缺点**：链表过长时查找效率退化为 O(n)。
- **优化**：链表转红黑树（如 Java HashMap）。
- **示例**：
  槽位 `3` 的链表： `A → B → C`（所有哈希到 `3` 的元素）。

---

### 3. **双重哈希 (Double Hashing)**

- **核心思想**：使用**两个哈希函数**生成探测序列。
- **探测序列**：`h(key, i) = (hash1(key) + i * hash2(key)) % size`
- **要求**：`hash2(key) ≠ 0` 且与表大小互质，避免循环。
- **优点**：最接近“理想均匀探测”，聚集最小。
- **示例**：
  `hash1(key)=3`, `hash2(key)=7`，冲突后尝试 `(3+1*7)=10` → `(3+2*7)=17`...

---

### 4. **再哈希 (Rehashing)**

**目的**：当负载因子过高（如 λ > 0.7）时，**扩容哈希表**并重新插入所有元素，保持效率。**步骤**：

1. 创建更大的新数组（通常翻倍，取质数大小）。
2. 遍历原数组所有元素，用**新哈希函数**计算其在新数组的位置。
3. 插入元素到新数组。
   **触发条件**：

- 开放寻址法：λ ≥ 0.7
- 链地址法：λ > 1（或链表长度 > 阈值）
  **影响**：扩容瞬间开销大，但均摊后操作仍为 O(1)。

---

### 关键对比总结


| **方法**       | 冲突解决策略     | 优点                  | 缺点                        |
| -------------- | ---------------- | --------------------- | --------------------------- |
| **开放寻址法** | 探测空闲槽       | 无额外内存开销        | 负载因子需严格控制 (λ<0.7) |
| - 线性探测     | 顺序探测         | 实现简单              | 易产生聚集                  |
| - 二次探测     | 平方步长跳跃     | 减少聚集              | 可能找不到空闲槽            |
| **链地址法**   | 链表存储冲突元素 | 允许高负载因子 (λ>1) | 链表过长时效率下降          |
| **双重哈希**   | 两个哈希函数组合 | 探测分布最均匀        | 计算成本稍高                |

---

### 实际应用场景

- **链地址法**：Java `HashMap`、Python `dict`（内部用数组+链表/红黑树）。
- **开放寻址法**：适合内存紧张的场景（如嵌入式系统）。
- **双重哈希**：对性能要求严苛的场景（如数据库索引）。
- **再哈希**：所有动态哈希表的必备机制（如 Redis 扩容时渐进式 rehash）。

理解这些机制的关键在于**平衡负载因子与冲突处理成本**。链地址法更通用，开放寻址法在 λ 较低时更节省内存，双重哈希则是开放寻址法中较优的实现方案。
