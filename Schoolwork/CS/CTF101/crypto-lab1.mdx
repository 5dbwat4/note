---
title: Crypto Lab 1ï¼šæ¶ˆæ¯åŠ å¯†å’Œæ•°å­—ç­¾å
---


import Card from '@md-components/card.vue';

{/* IRON:myisijv597slx1bxx338qrs7sdv438kw:OB */}

import PasswordContainer from '@md-components/passwordContainer.vue';

<PasswordContainer md5="9d5877b5a59773af69919a1544ea8c08">

# Task: vigenere-encrypt (40%)

<Card type="task" title="ä»»åŠ¡">

è¯¾ä¸Šä»‹ç»äº†ç»´å‰å°¼äºšï¼ˆVigenereï¼‰å¯†ç ï¼Œå…¶ä½œä¸ºå¤šè¡¨åŠ å¯†çš„æ›¿æ¢å¯†ç ï¼ŒåŠ å¯†å¼ºåº¦ç›¸å¯¹äºå•è¡¨æ›¿æ¢å·²ç»å¢å¼ºäº†è®¸å¤šï¼Œä½†æ˜¯ä»ç„¶ä¼šå› è¯­è¨€å­¦ç‰¹æ€§è¢«è½»æ¾ç ´è§£ã€‚

ç»´å‰å°¼äºšå¯†ç çš„ç ´è§£æ–¹æ³•åœ¨è¯¾ä¸Šæœ‰ä¸€å®šä»‹ç»ï¼Œä¹Ÿåšäº†ä¸€äº›å±•ç¤ºï¼Œå¯†é’¥çš„ç ´è§£åŸºæœ¬åˆ†ä¸ºä»¥ä¸‹ä¸¤æ­¥ï¼š

1. çˆ†ç ´çŒœæµ‹å¯†é’¥é•¿åº¦
    - ç¬¬ä¸€ç§æ–¹æ³•æ˜¯å¯»æ‰¾å¤šæ¬¡é‡å¤çš„å¯†æ–‡ï¼Œç„¶åè®¡ç®—å¯†æ–‡é—´éš”çš„æœ€å¤§å…¬å› æ•°ï¼Œå³ä¸ºæœ€æœ‰å¯èƒ½çš„å¯†é’¥é•¿åº¦ï¼Œè¿™ä¸ªåœ¨è¯¾ä¸Šå·²ä½œå±•ç¤º
    - æ­¤å¤–ï¼Œä¹Ÿå¯ä»¥çˆ†ç ´å¯†é’¥é•¿åº¦ï¼Œè®¡ç®—å¯†æ–‡ä¸­ç›¸éš”è¯¥é•¿åº¦çš„å­—ç¬¦é‡åˆäº†å‡ æ¬¡ï¼Œæ•´ä½“é‡åˆæ¬¡æ•°æœ€å¤šçš„é•¿åº¦å¯èƒ½å°±æ˜¯å¯†é’¥é•¿åº¦
2. é€ä½çˆ†ç ´å¯†é’¥
    - ç¡®å®šäº†å¯†é’¥é•¿åº¦åï¼Œå¯ä»¥é€šè¿‡å­—æ¯é¢‘ç‡æˆ–è€…å•è¯é¢‘ç‡çŒœæµ‹å¯†é’¥çš„å…¶ä¸­å‡ ä½
    - éšåæ ¹æ®å·²è§£å¯†çš„éƒ¨åˆ†çŒœæµ‹å•è¯ï¼Œç»§ç»­è¿›è¡Œå¯†é’¥çš„ç ´è§£

æœ¬ Task éœ€è¦å®Œæˆ ZJU School-Bus ä¸Šçš„ [vigenere-encrypt](https://zjusec.com/challenges/31) ä¸€é¢˜ï¼Œåœ¨å®éªŒæŠ¥å‘Šä¸­ç®€å•æè¿°è¿™é“é¢˜çš„åšæ³•ã€‚å¦‚æœæ²¡æ³•å®Œæ•´åšå‡ºï¼Œä¹Ÿå¯ä»¥å™è¿°è‡ªå·±çš„æ€è·¯å’Œè§£é¢˜è¿‡ç¨‹ï¼Œä¼šæ ¹æ®å®Œæˆæƒ…å†µç»™åˆ†ã€‚æœ¬é¢˜åˆ†å€¼ 40 åˆ†ã€‚

</Card>

1. çŒœæµ‹å¯†é’¥çš„é•¿åº¦
    æˆ‘ä»¬ä½¿ç”¨[Index of coincidence](https://en.wikipedia.org/wiki/Index_of_coincidence)ä½œä¸ºè¯„åˆ¤æŒ‡æ ‡
    ```python
    import math

    # å®šä¹‰å­—ç¬¦é›†ï¼ˆä¸åŠ å¯†æ—¶ç›¸åŒï¼‰
    text_list = ' !"#$%&\'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\t\n'

    def compute_ic(s):
        """è®¡ç®—å­—ç¬¦ä¸²sçš„é‡åˆæŒ‡æ•°(IoC)"""
        n = len(s)
        if n <= 1:
            return 0.0

        freq = {}
        for char in s:
            freq[char] = freq.get(char, 0) + 1

        total = 0
        for count in freq.values():
            total += count * (count - 1)

        return total / (n * (n - 1))

    def main():
        # è¯»å–å¯†æ–‡
        with open('cipher.txt', 'r') as f:
            cipher = f.read()

        # è®¾å®šå¯†é’¥é•¿åº¦æµ‹è¯•èŒƒå›´ (1-40)
        min_key_len = 1
        max_key_len = 40
        results = []

        for key_len in range(min_key_len, max_key_len + 1):
            # æŒ‰å¯†é’¥é•¿åº¦åˆ†ç»„
            groups = [''] * key_len
            for idx, char in enumerate(cipher):
                group_idx = idx % key_len
                groups[group_idx] += char

            # è®¡ç®—å¹³å‡IC
            avg_ic = 0.0
            valid_groups = 0
            for group in groups:
                if len(group) >= 2:  # éœ€è¦è¶³å¤Ÿå­—ç¬¦è®¡ç®—IC
                    group_ic = compute_ic(group)
                    avg_ic += group_ic
                    valid_groups += 1

            if valid_groups > 0:
                avg_ic /= valid_groups
            else:
                avg_ic = 0.0

            results.append((key_len, avg_ic))

        # æŒ‰ICå€¼é™åºæ’åº
        results.sort(key=lambda x: x[1], reverse=True)

        # è¾“å‡ºç»“æœ
        print("å¯†é’¥é•¿åº¦å€™é€‰ (æŒ‰ICå€¼é™åº):")
        print("é•¿åº¦\tICå€¼\tä¸éšæœºæ–‡æœ¬å·®å€¼")
        for key_len, ic in results:
            random_ic = 1 / len(text_list)  # éšæœºæ–‡æœ¬çš„æœŸæœ›IC
            ic_diff = ic - random_ic
            print(f"{key_len}\t{ic:.6f}\t{ic_diff:+.6f}")

    if __name__ == "__main__":
        main()
    ```

    å¾—å‡ºlen=29æ—¶IoCå€¼åˆé€‚( 0.070525 )ï¼Œå› æ­¤é€‰æ‹©29ä½œä¸ºå¯†é’¥é•¿åº¦

2. é€ä½çˆ†ç ´å¯†é’¥
    ```python
    from collections import Counter

    # å®šä¹‰å­—ç¬¦é›†ï¼ˆä¸åŠ å¯†æ—¶ç›¸åŒï¼‰
    text_list = ' !"#$%&\'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\t\n'
    mod = len(text_list)  # 97

    def mod_inv(a, m=mod):
        """è®¡ç®—aåœ¨æ¨¡mä¸‹çš„ä¹˜æ³•é€†å…ƒ"""
        for i in range(1, m):
            if (a * i) % m == 1:
                return i
        return None  # aä¸º0æ—¶æ— é€†å…ƒï¼ˆä½†aâˆˆ[1,96]æ€»æœ‰é€†å…ƒï¼‰

    def rate(text):
        """
        è®¡ç®—æ–‡æœ¬ä¸­ï¼šå°å†™å­—æ¯ä¸ªæ•° + ç©ºæ ¼ä¸ªæ•° + å¤§å†™å­—æ¯ä¸ªæ•° * 0.5
        """
        lowercase_count = 0
        uppercase_count = 0
        space_count = 0

        for char in text:
            if char.islower():
                lowercase_count += 1
            elif char.isupper():
                uppercase_count += 1
            elif char == ' ':  # åªè®¡ç®—ç©ºæ ¼å­—ç¬¦
                space_count += 1

        # è®¡ç®—æ€»åˆ†ï¼šå°å†™å­—æ¯å…¨å€¼ + ç©ºæ ¼å…¨å€¼ + å¤§å†™å­—æ¯åŠå€¼
        total_score = lowercase_count + space_count + (uppercase_count * 0.5)
        return total_score

    def break_single_key(cipher_group):
        """çˆ†ç ´å•ä¸ªå¯†é’¥"""
        best_key = 0
        best_ic = -1

        for k in range(1, mod):  # å°è¯•æ‰€æœ‰å¯èƒ½å¯†é’¥kâˆˆ[1,96]
            inv_k = mod_inv(k)
            decrypted = []
            for c in cipher_group:
                idx_c = text_list.index(c)
                idx_p = (idx_c * inv_k) % mod
                decrypted.append(text_list[idx_p])
            decrypted_text = ''.join(decrypted)
            ic_val = rate(decrypted_text)

            if ic_val > best_ic:
                best_ic = ic_val
                best_key = k
        return best_key

    def break_vigenere_key(ciphertext, key_length):
        """çˆ†ç ´æ•´ä¸ªVigenÃ¨reå¯†é’¥ï¼ˆå·²çŸ¥å¯†é’¥é•¿åº¦ï¼‰"""
        # æŒ‰å¯†é’¥é•¿åº¦åˆ†ç»„å¯†æ–‡
        groups = [''] * key_length
        for i, char in enumerate(ciphertext):
            groups[i % key_length] += char

        print("åˆ†ç»„åçš„å¯†æ–‡ï¼š", "\n\n".join(groups))
        # å¯¹æ¯ç»„çˆ†ç ´å•ä¸ªå¯†é’¥
        key = []
        for group in groups:
            key.append(break_single_key(group))
        return key

    def decrypt(ciphertext, key):
        """ç”¨å¯†é’¥è§£å¯†å¯†æ–‡"""
        inv_key = [mod_inv(k) for k in key]  # è®¡ç®—å¯†é’¥çš„é€†å…ƒ
        plaintext = []
        for i, char in enumerate(ciphertext):
            idx_c = text_list.index(char)
            idx_p = (idx_c * inv_key[i % len(key)]) % mod
            plaintext.append(text_list[idx_p])
        return ''.join(plaintext)

    # ä¸»ç¨‹åº
    if __name__ == "__main__":
        # è¯»å–å¯†æ–‡æ–‡ä»¶
        with open('cipher.txt', 'r') as f:
            ciphertext = f.read()

        # è¾“å…¥å·²çŸ¥çš„å¯†é’¥é•¿åº¦ï¼ˆé€šè¿‡å…¶ä»–æ–¹æ³•è·å¾—ï¼‰
        key_length = 29

        # çˆ†ç ´å¯†é’¥
        key = break_vigenere_key(ciphertext, key_length)
        print(f"çˆ†ç ´å¾—åˆ°çš„å¯†é’¥: {key}")

        # ç”¨å¯†é’¥è§£å¯†å¯†æ–‡
        plaintext = decrypt(ciphertext, key)

        # ä¿å­˜è§£å¯†ç»“æœ
        with open('decrypted.txt', 'w') as f:
            f.write(plaintext)
        print("è§£å¯†ç»“æœå·²ä¿å­˜åˆ° decrypted.txt")
    ```

    å…³äºè¯„åˆ¤keyæ­£ç¡®æ€§çš„é‚£ä¸ªè¯„åˆ†å‡½æ•°ï¼Œè€ƒè™‘åˆ°åŸæ–‡æ˜¯ã€ŠTOEFL reading passageã€‹ï¼Œæ˜¾ç„¶åº”å½“ç”±å¤§é‡å°å†™å­—æ¯ï¼Œä¸€äº›ç©ºæ ¼ï¼Œå°‘é‡å¤§å†™å­—æ¯ï¼Œä»¥åŠä¸€ä¸ªåµŒå…¥çš„flagç»„æˆï¼Œé‚£ä¹ˆå¯ä»¥ç›´æ¥è®¤å®šè§£å¯†åæ»¡è¶³è¿™ä¸ªç‰¹ç‚¹çš„keyæ˜¯æ­£ç¡®çš„keyã€‚

    æ‰€ä»¥æˆ‘ä»¬å¹²è„†ä¸ç”¨IoCäº†ï¼Œç›´æ¥ä½¿ç”¨ã€Šå°å†™å­—æ¯ä¸ªæ•° + ç©ºæ ¼ä¸ªæ•° + å¤§å†™å­—æ¯ä¸ªæ•° * 0.5ã€‹è¿™ä¸€ ~~*å…ˆè¿›çš„åŸåˆ›æ€§çš„*~~ è¯„åˆ†å‡½æ•°æ¥è¯„åˆ¤keyçš„æ­£ç¡®æ€§ã€‚

<pre style="font-family: v-mono, SFMono-Regular, Menlo, Consolas, Courier, monospace;word-wrap: break-word;white-space: pre-wrap;overflow-wrap: break-word;font-size: 14px;line-height: 1.5em;">
By the mid-nineteenth century, the term "icebox" had entered the American language, but ice was still only beginning to affect the diet of ordinary citizens in the United States. The ice trade grew with the growth of cities. Ice was used in hotels, taverns, and hospitals, and by some forward-looking city dealers in fresh meat, fresh fish, and butter.After the Civil War (1861-1865), as ice was used to refrigerate freight cars, it also came into household use. Even before 1880, half the ice sold in New York, Philadelphia, and Baltimore, and one-third of that sold in Boston and Chicago, went to families for their own use. This had become possible because a new household convenience, the icebox, a precursor of the modern refrigerator, had been invented.
Making an efficient icebox was not as easy as we might now suppose. In the early nineteenth century, the knowledge of the physics of heat, which was essential to a science of refrigeration, was rudimentary. The commonsense notion that the best icebox was one that prevented the ice from melting was of course mistaken, for it was the melting of the ice that performed the cooling.
Nevertheless, early efforts to economize ice included wrapping the ice in blankets, which kept the ice from doing its job. Not until near the end of the nineteenth century did inventors achieve the delicate balance of insulation and circulation needed for an efficient icebox.
fLaG:AAA\{i_like_T0ef1_v3ry_M3uh!!!\}
But as early as 1803, an ingenious Maryland farmer, Thomas Moore, had been on the right track. He owned a farm about twenty miles outside the city of Washington, for which the village of Georgetown was the market center. When he used an icebox of his own design to transport his butter to market, he found that customers would pass up the rapidly melting stuff in the tubs of his competitors to pay a premium price for his butter, still fresh and hard in neat, one-pound bricks.
One advantage of his icebox, Moore explained, was that farmers would no longer have to travel to market at night in order to keep their produce cool.
Perhaps the most obvious way artistic creation reflects how people live is by mirroring the environment - the materials and technologies available to a culture. Stone, wood, tree bark, clay, and sand are generally available materials. In addition, depending on the locality, other resources may be accessible: shells, horns, gold, copper, and silver. The different uses to which societies put these materials are of interest to anthropologists who may ask, for example, why people choose to use clay and not copper when both items are available. Although there are no conclusive answers yet, the way in which a society views its environment is sometimes apparent in its choice and use of artistic materials. The use of certain metals, for example, may be reserved for ceremonial objects of special importance. Or the belief in the supernatural powers of a stone or tree may cause a sculptor to be sensitive to that material.
What is particularly meaningful to anthropologist is the realization that although the materials available to a society may to some extent limit or influence what it can do artistically, the materials by no means determine what is done. Why do the artists in Japanese society rake sand into patterns; and the artists in Roman society melt sand to form glass? Moreover, even when the same material is used in the same way by members of different societies, the form or style of the work varies enormously from culture to culture. A society may simply choose to represent objects or phenomena that are important to its population. An examination of the art of the Middle Ages tells us something about the medieval preoccupation with theological doctrine. In addition to revealing the primary concerns of a society, the content of that society's art may also reflect the culture's social stratification.
</pre>

å±…ç„¶ä¸€æ¬¡å°±æˆåŠŸäº†è¿™ä¸ªå±å®æ²¡æƒ³åˆ°ï¼Œæˆ‘è¿˜ä»¥ä¸ºä¼šæœ‰å¤æ‚çš„è°ƒè¯•score functionçš„è¿‡ç¨‹

# Challenges & bonus (75%)

## å¤å…¸å¯†ç çš„æ‹“å±• (60%)

<Card type="task" title="ä»»åŠ¡">

å¸Œå°”å¯†ç æ˜¯å¤å…¸å¯†ç å­¦ä¸çº¿æ€§ä»£æ•°çš„ç»“åˆï¼Œé€šè¿‡å¸Œå°”å¯†ç çš„ç ´è§£ï¼Œä¹Ÿå¯ä»¥åˆæ­¥æ„Ÿå—ç°ä»£å¯†ç å­¦çš„ç‰¹ç‚¹ï¼šä»¥æ•°å­¦ä¸ºåŸºç¡€çš„ç®—æ³•æ„å»ºå’Œç ´è§£ã€‚

æœ¬ Challenge éœ€è¦å®Œæˆ ZJU School-Bus ä¸Šçš„ [HSC](https://zjusec.com/challenges/168) ä¸€é¢˜ï¼Œåœ¨å®éªŒæŠ¥å‘Šä¸­ç®€å•æè¿°è¿™é“é¢˜çš„åšæ³•ã€‚

è¿™é‡Œé¦–å…ˆå…ˆè®©åŒå­¦ä»¬å­¦ä¹ ä¸€ä¸‹ sagemath çš„ä½¿ç”¨æ–¹æ³•ï¼Œå¯¹å®Œæˆæœ¬é¢˜æˆ–è€…ä¹‹åä¸“é¢˜çš„å­¦ä¹ æœ‰è¾ƒå¤§çš„å¸®åŠ©ã€‚

- å¯¹é¢˜ç›®ä¸­çš„ MT çŸ©é˜µè¿›è¡Œéšæœºèµ‹å€¼ï¼Œä½¿å…¶å¯é€†ï¼Œä½¿ç”¨ sage æ±‚å‡ºå®ƒçš„é€†çŸ©é˜µï¼Œåˆ†å€¼ 10 åˆ†
- éšæœºè®¾ç½® flag ç”Ÿæˆ FTï¼Œè®¡ç®— RTï¼Œå†é€šè¿‡ RT å’Œ MT æ±‚å‡º FT çš„å€¼ï¼Œä¸åŸ FT è¿›è¡Œæ¯”å¯¹ï¼Œåˆ†å€¼ 10 åˆ†

å¦‚æœåç»­æ²¡æœ‰é€‰æ‹©å¯†ç å­¦ä¸“é¢˜çš„æ‰“ç®—ï¼Œä¸Šè¿°å¤ç°å¯ä»¥ä½¿ç”¨[åœ¨çº¿ç¯å¢ƒ](https://sagecell.sagemath.org/)ã€‚

HSC é¢˜ç›®åˆ†å€¼ 40 åˆ†ï¼ŒåŠ ä¸Š sage å¤ç°éƒ¨åˆ†æœ¬ Challenge å…± 60 åˆ†ï¼ŒåŒæ ·ï¼Œå¦‚æœæ²¡æ³•å®Œæ•´åšå‡ºï¼Œä¹Ÿå¯ä»¥å™è¿°è‡ªå·±çš„æ€è·¯å’Œè§£é¢˜è¿‡ç¨‹ï¼Œä¼šæ ¹æ®å®Œæˆæƒ…å†µç»™åˆ†ã€‚

</Card>

### å¯¹é¢˜ç›®ä¸­çš„ MT çŸ©é˜µè¿›è¡Œéšæœºèµ‹å€¼ï¼Œä½¿å…¶å¯é€†ï¼Œä½¿ç”¨ sage æ±‚å‡ºå®ƒçš„é€†çŸ©é˜µ

```python
from sage.all import *

# éšæœºç”Ÿæˆå¯é€†çŸ©é˜µ MT
while True:
    # ç”Ÿæˆéšæœº 3x3 çŸ©é˜µ
    MT = matrix(Zmod(256), [[randint(0, 255) for _ in range(3)] for _ in range(3)])

    if MT.is_invertible():
        break

print("éšæœºç”Ÿæˆçš„ MT çŸ©é˜µ:")
print(MT)
print("MT çš„é€†çŸ©é˜µ:")
print(MT.inverse())
```
### éšæœºè®¾ç½® flag ç”Ÿæˆ FTï¼Œè®¡ç®— RTï¼Œå†é€šè¿‡ RT å’Œ MT æ±‚å‡º FT çš„å€¼ï¼Œä¸åŸ FT è¿›è¡Œæ¯”å¯¹

```python
# ...
# Now we have MT which is a 3x3 invertible matrix

import random
import string

# 2. éšæœºç”Ÿæˆ flag (30ä¸ªå­—ç¬¦ï¼Œæ ¼å¼ä¸º AAA{...})
def generate_random_flag():
    prefix = "AAA{"
    suffix = "}"
    # ç”Ÿæˆ25ä¸ªéšæœºå¯æ‰“å°å­—ç¬¦
    middle = ''.join(random.choices(string.ascii_letters + string.digits + "_-", k=25))
    return prefix + middle + suffix

flag = generate_random_flag()
print("éšæœºç”Ÿæˆçš„ flag:", flag)

# 3. æ„å»º FT çŸ©é˜µ (3x10)
FT = matrix(Zmod(256), 3, 10)
for i in range(3):
    for j in range(10):
        FT[i, j] = ord(flag[i + j * 3])

print("FT çŸ©é˜µ:")
print(FT)

# 4. è®¡ç®— RT = MT * FT
RT = MT * FT
print("RT çŸ©é˜µ:")
print(RT)

# 5. æ±‚å‡º FT çš„å€¼
FT_recovered = MT.inverse() * RT

print("FT æ¢å¤åçš„çŸ©é˜µ:")
print(FT_recovered)

# 6. éªŒè¯ FT æ¢å¤æ˜¯å¦æ­£ç¡®
flag_recovered = ""
for j in range(10):
    for i in range(3):
        flag_recovered += chr(FT_recovered[i, j])
print("æ¢å¤çš„ flag:", flag_recovered)
if flag_recovered == flag:
    print("FT æ¢å¤æˆåŠŸï¼Œflag åŒ¹é…ï¼")
else:
    print("FT æ¢å¤å¤±è´¥ï¼Œflag ä¸åŒ¹é…ã€‚")
```

### HSC

çˆ†ç ´4ä½flagæ¥è¿˜åŸ MT çŸ©é˜µï¼Œé€šè¿‡FTæ˜¯å¦å‡ä¸ºå¯æ‰“å°å­—ç¬¦æ¥åˆ¤æ–­æ˜¯å¦æ­£ç¡®ã€‚

```python
from sage.all import *
import random
import string

result_bytes = b'\xfc\xf2\x1dE\xf7\xd8\xf7\x1e\xed\xccQ\x8b9:z\xb5\xc7\xca\xea\xcd\xb4b\xdd\xcb\xf2\x939\x0b\xec\xf2'
RT_0 =  matrix(Zmod(256), [[252,69,11],[242,247,236],[29,216,242]])
bruteforce = string.ascii_letters + string.digits + "_-"
RT = matrix(Zmod(256), 3,10)
for i in range(10):
	for j in range(3):
	    RT[j, i]=result_bytes[j+i*3]

# We are bruteforce 64**4 which is acceptable

def all_char_is_printable(matrix):
    for i in range(matrix.nrows()):
        for j in range(matrix.ncols()):
            if matrix[i, j] < 32 or matrix[i, j] > 126:
                return False
    return True

def do_a_single_test(FT_0):
    FT_recovered = FT_0 * RT_0.inverse() * RT
    if not all_char_is_printable(FT_recovered):
        return
    flag_recovered = ""
    for j in range(10):
        for i in range(3):
            flag_recovered += chr(FT_recovered[i, j])
    print("æ¢å¤çš„ flag:", flag_recovered)

def do_bruteforce():
    FT_0 = matrix(Zmod(256),3,3)
    FT_0 [0,0] = 65
    FT_0 [1,0] = 65
    FT_0 [2,0] = 65
    FT_0 [0,1] = 123
    FT_0 [2,2] = 125
    for i1 in bruteforce:
        FT_0 [1,1] = ord(i1)
        for i2 in bruteforce:
            FT_0 [2,1] = ord(i2)
            print("Report status: ", i1, i2)
            for i3 in bruteforce:
                FT_0 [0,2] = ord(i3)
                for i4 in bruteforce:
                    FT_0 [1,2] = ord(i4)
                    do_a_single_test(FT_0)

do_bruteforce()
```

ä½†æ˜¯æ²¡çˆ†å‡ºæ¥ğŸ˜¥

## éšæœºæ•°çš„é¢„æµ‹ (50%)

<Card type="task" title="ä»»åŠ¡">

éšæœºæ•°åœ¨å¯†ç å­¦ä¸­èµ·ç€é‡è¦çš„ä½œç”¨ï¼Œå°¤å…¶æ˜¯åœ¨å¯†é’¥ç”Ÿæˆå’ŒåŠ å¯†ç®—æ³•ä¸­ã€‚

åœ¨è¯¾ä¸Šæˆ‘ä»¬ä¸»è¦ä»‹ç»äº†éšæœºæ•°çš„ç”Ÿæˆå’Œé¢„æµ‹æ–¹æ³•ï¼Œä»¥åŠç›¸å…³çš„æ”»å‡»æ–¹å¼ï¼Œä½ å¯ä»¥å°è¯•å®ç°ä¸€äº›ç®€å•çš„éšæœºæ•°é¢„æµ‹æ”»å‡»ã€‚

æœ¬ Challenge éœ€è¦å®Œæˆ ZJU School-Bus ä¸Šçš„ [PRNG Study1](https://zjusec.com/challenges/94) ä¸€é¢˜ï¼Œåœ¨å®éªŒæŠ¥å‘Šä¸­ç®€å•æè¿°è¿™é“é¢˜çš„åšæ³•ã€‚å®Œæˆæœ¬é¢˜å¯ä»¥è·å¾— 50 åˆ†ã€‚

- å¦‚æœæƒ³è¦è·å¾—é¢å¤–çš„ 15 åˆ†å¥–åŠ±ï¼Œä½ å¯ä»¥å†é€‰æ‹©ä»»æ„ä¸€ç§è¯­è¨€çš„éšæœºæ•°ç”Ÿæˆå™¨è¿›è¡Œåˆ†æå¹¶é˜è¿°æ”»å‡»çš„æ€è·¯ã€‚

å¦‚æœæ²¡æ³•å®Œæ•´åšå‡ºï¼Œä¹Ÿå¯ä»¥å™è¿°è‡ªå·±çš„æ€è·¯å’Œè§£é¢˜è¿‡ç¨‹ï¼Œä¼šæ ¹æ®å®Œæˆæƒ…å†µç»™åˆ†ã€‚

</Card>

### PRNG Study1

```python
from pwn import *

sh = remote('10.214.160.13',12600)



powStr = sh.recvline().decode() # 'sha256(XXXX + iL9MgF7ZDXba3SjK) == e9281fd69ad6c142a118e2f1f4a24129277377bb96c06f7c08277da7620d5825'
sh.recvline()


import hashlib
import string

def solve_proof_of_work(proof, digest):
    # The charset to use for the brute force (same as in the proof_of_work function)
    charset = string.ascii_letters + string.digits
    
    # Iterate over all possible combinations of the 4-character prefix
    for i in range(len(charset)):
        print(f"Testing prefix {i+1}/{len(charset)}", end='\r')
        for j in range(len(charset)):
            for k in range(len(charset)):
                for l in range(len(charset)):
                    prefix = f"{charset[i]}{charset[j]}{charset[k]}{charset[l]}"
                    # print((prefix + proof).encode('utf-8'))
                    if hashlib.sha256((prefix + proof).encode()).hexdigest() == digest:
                        return prefix
    return None

proof = powStr.split(') == ')[0][14:]
digest = powStr.split(') == ')[1][:-1]

log.info(f"Solving PoW with Proof: {proof}, Digest: {digest}")
solution = solve_proof_of_work(proof, digest)
log.success(f"Solution found: {solution}")
sh.sendline(bytes(solution, 'utf-8'))
# sh.interactive()

sh.recvuntil(b'Level:')
sh.sendline(b'1')

sh.recvline().decode()








log.info('Receiving leaked data')
leaked_data_str = sh.recvline().decode() # '[8861151185762077140, 8786055871148907391, 9031881494187854144, 2057099155505662839, 10920481184413936408, 8863944909863100605]'
leaked_data = [int(x) for x in leaked_data_str[1:-2].split(', ')]

print(leaked_data)

# sh.recvline().decode()

log.info(f"Cracking LCD")

from functools import reduce
from math import gcd

# https://zer0yu.github.io/2018/11/02/Cracking-LCG/

def crack_unknown_increment(states, modulus, multiplier):
    increment = (states[1] - states[0]*multiplier) % modulus
    return modulus, multiplier, increment

def crack_unknown_multiplier(states, modulus):
    multiplier = (states[2] - states[1]) * modinv(states[1] - states[0], modulus) % modulus
    return crack_unknown_increment(states, modulus, multiplier)

def egcd(a, b):
    if a == 0:
        return (b, 0, 1)
    else:
        g, x, y = egcd(b % a, a)
        return (g, y - (b // a) * x, x)

def modinv(b, n):
    g, x, _ = egcd(b, n)
    if g == 1:
        return x % n
    
def crack_unknown_modulus(states):
    diffs = [s1 - s0 for s0, s1 in zip(states, states[1:])]
    zeroes = [t2*t0 - t1*t1 for t0, t1, t2 in zip(diffs, diffs[1:], diffs[2:])]
    modulus = abs(reduce(gcd, zeroes))
    return crack_unknown_multiplier(states, modulus)


n,a,b = crack_unknown_modulus(leaked_data)

log.info(f"Reversed param: n={n}, a={a}, b={b}")

state = leaked_data[0]
assert((a*state + b) % n==leaked_data[1])

for i in range(6):
    # sh.recvuntil('Guess: ').decode()
    print(sh.recv())
    state = leaked_data[i]
    print(f"Guess {i+1}: {state}")
    sh.sendline(str(state).encode())

for i in range(6,23):
    # sh.recvuntil('Guess: ').decode()
    print(sh.recv())
    state = (a*state + b) % n
    print(f"Guess {i+1}: {state}")
    sh.sendline(str(state).encode())


sh.interactive()

# sh.recvline().decode()
# print('line', sh.recvline().decode())
# print('line', sh.recvline().decode())
# print('line', sh.recvline().decode())



# AAA{8a8y_L1near_C0ngruen7ial_G3ner4tors_Cracking|fee9a4cd03}
```


</PasswordContainer>